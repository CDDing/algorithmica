---
title: Instruction Set Architectures
weight: -1
---

소프트웨어 엔지니어는 추상화를 만들고 사용하는 것을 좋아합니다.

URL을 로드할 때 얼마나 많은 일이 일어나는지를 상상해보세요. 사용자가 키보드에 무언가를 입력하면 키 입력이 운영체제에 의해 감지되어 브라우저로 전달됩니다. 브라우저는 URL을 파싱하고 운영체제에 네트워크 요청을 하도록 요청합니다. 그러면 DNS, 라우팅, TCP, HTTP, 그리고 다른 OSI 계층들이 작동합니다. 브라우저는 HTML을 파싱하고, JavaScript가 동작합니다. 페이지의 일부 표현은 GPU로 전달되어 렌더링되며, 이미지 프레임은 모니터로 전송됩니다. 이 과정의 각 단계는 아마도 수십 개 이상의 더 세부적인 작업을 포함하고 있을 것입니다.

추상화는 이 모든 복잡성을, 특정 모듈이 구체적인 구현에 의존하지 않고 어떤 기능을 수행할 수 있는지를 설명하는 단일 인터페이스로 축소하는 데 도움을 줍니다. 이는 두 가지 이점을 제공합니다.

- 고수준 모듈에서 작업하는 엔지니어는 훨씬 작은 인터페이스만 이해하면 됩니다.
- 모듈 자체를 작업하는 엔지니어는 해당 계약을 준수하는 한, 구현을 자유롭게 최적화하고 리팩토링 할 수 있는 유연성을 갖습니다.

하드웨어 엔지니어 또한 추상화를 좋아합니다. CPU의 추상화는 명령어 집합 구조(Instruction Set Architecture, ISA)라고 하며, 이는 프로그래머 관점에서 컴퓨터가 어떻게 동작해야 하는지를 정의합니다. 이는 소프트웨어 인터페이스와 유사하게, 컴퓨터 엔지니어가 기존 CPU 설계를 개선할 수 있게 해주며, 사용자, 즉 우리 프로그래머들에게는 이전에 작동하던 프로그램이 새로운 칩에서도 계속 동작할 것이라는 신뢰를 제공합니다.

ISA는 본질적으로 하드웨어가 기계어를 어떻게 해석해야 하는지를 정의합니다. 명령어와 그들의 바이너리 인코딩 외에도, ISA는 레지스터의 수와 크기 및 용도, 메모리 모델, 입출력 모델 등을 정의합니다. 소프트웨어 인터페이스처럼 ISA 또한 확장 가능합니다. 실제로 성능을 향상시키기 위해 새로운 특수 명령어를 추가하는 방식으로 업데이트 되며, 대부분은 이전 버전과의 호환성을 유지하도록 설계됩니다.

### RISC vs CISC

역사적으로 많은 경쟁 ISA들이 사용되어 왔습니다. 하지만 [문자 인코딩이나 인스턴트 메신저 프로토콜](https://xkcd.com/927/)
과는 달리, 완전히 별개의 ISA를 개발하고 유지하는데는 많은 비용이 들기 때문에, 주요 CPU 설계는 결국 하나 혹은 두 개의 ISA 계열로 수렴하게 되었습니다.

- 하나는 **Arm 칩**으로, 이는 대부분의 모바일 기기 뿐만 아니라 TV, 스마트 냉장고, 전자레인지, [자동차의 자율주행 시스템](https://en.wikipedia.org/wiki/Tesla_Autopilot)등 컴퓨터와 유사한 다양한 장치에 사용됩니다.이 칩은 동명의 영국 기업과 애플, 삼성 등 여러 전자기기 제조업체들에 의해 설계되었습니다.
- 다른 하나는 **x86**[^x86] 칩입니다. 이는 대부분의 서버와 데스크탑에서 사용되며, 대표적인 예외로는 애플의 M1 맥북, AWS의 Graviton 프로세서, 그리고 현재 [세계에서 가장 빠른 슈퍼 컴퓨터](https://en.wikipedia.org/wiki/Fugaku_(supercomputer))등이 있습니다. 이들 모두는 Arm 기반 CPU를 사용합니다. x86칩은 인텔과 AMD라는 두 회사에 의해 독점적으로 설계되고 있습니다.

[^x86]: 현대 64비트 버전의 x86은 "AMD64", "Intel 64" 혹은 좀 더 제조사 중립적인 이름인 "x86-64" 혹은 "x64"로 알려져 있습니다. Arm의 유사한 64비트 확장은 "AArch64" 혹은 "ARM64"로 불립니다. 이 책에서는 64비트 버전을 나타내는 순수 "x86"과 "Arm"을 사용할 것입니다.

두 ISA의 가장 큰 차이는 구조적 복잡도이며, 이는 엄밀한 기술적 속성이라기보다는 설계 철학에 가깝습니다.

- Arm CPU는 RISC(**Reduced** Instruction Set Computer) 구조로, 명령어 집합을 작고 고도화된 형태로 유지함으로써 성능을 향상시킵니다. 다만, 일부 드물게 사용되는 연산은 여러 명령어로 구성된 서브루틴으로 구현해야 합니다.
  x86 CPU는 CISC(**Complex** Instruction Set Computer) 구조로, 성능 향상을 위해 실제 프로그램에서 자주 사용되지 않는 특수한 명령어까지 포함하는 많은 명령어를 제공합니다.

RISC 설계의 가장 큰 장점은 더 단순하고 더 작은 칩을 만들 수 있다는 점이며, 이는 제조 비용 절감과 전력 소비 감소로 이어집니다. 따라서 Arm이 배터리 기반의 범용 장치를 지배하고, 복잡한 신경망 연산이나 갈루아 필드 계산 같은 고도로 특수화된 작업은 x86이 담당하게 된 시장 분화는 당연한 결과라고 볼 수 있습니다.

<!--

The two architectures are functionally similar, both sharing concepts such as pipelines, execution ports, and SIMD instructions, but since most readers are interested in optimizing applications for mainstream servers and desktops, we will mainly focus on x86 in this book.

-->
